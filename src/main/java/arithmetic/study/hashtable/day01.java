package arithmetic.study.hashtable;

/***
 * 散列表
 */
public class day01 {

    /**
     * 散列函数设计的基本要求
     * 1.散列函数计算得到的值是一个非负整数。
     * 2.如果key1=key2，那么hash(key1)=hash(key2)。
     * 3.如果key1≠key2，那么hash(key1)≠hash(key2)。
     * 其中第三点看起来合情合理，但是要想找到符合第三点的散列函数几乎是不可能的，这就是著名的hash碰撞。
     */

    /***
     * 再好的散列函数也无法避免hash碰撞，目前无法从根本上解决问题，只能在产生hash碰撞后实施补救措施，目前常用的方法有两种。
     *
     * 1.开放寻址法
     * 开放寻址法的核心思想是，如果出现了hash碰撞，我们就重新探测一个空闲位置，将其插入。
     *
     * 2.链表法
     * 即通过数据和链表的组合结构来解决hash碰撞，储存值的结构为一个数组，数组中每个下标对应的是一个链表，链表中每个结点的data值都存的是一个KV键值对。
     * 如果两个不同的key值计算出的hash值一样，即它们放入数组的下标一样，那么它们就直接插入对应下标下的链表即可。
     * 当取数据时，根据key的hash值找到数组的对应下标，然后去遍历并且equals链表结点中的key值，如果相等就取出来。
     */
}
