package arithmetic.study.array;

import java.util.Arrays;

/***
 * 每一种编程语言中，基本都会有数组这种数据类型。
 * 不过它不仅是一种数据类型，还是一种最基础的数据结构。
 * 尽管数组看起来非常的基础、简单，但是很多人都没有理解这个基础数据结构的精髓。
 */
public class day01 {

    /***
     * 什么是数组
     * 数组是一种线性表结构，它用一组连续的内存空间，来储存一组具有相同类型的数据
     */

    /***
     * 线性表
     * 顾名思义，线性表就是数据排成像一条线一样的结构。
     * 每个线性表上的数据最多只有前和后两个方向，除了数组，链表、队列、栈也是线性表结构。
     * 而与线性表对立的概念是非线性表，比如二叉树、堆、图等，之所以叫非线性，是因为在非线性表中，数据之间并不是前后那么简单。
     */

    /***
     * 连续的内存空间和相同类型的数据
     * 正因为这两个限制，它才有了一个堪称"杀手锏"的特性，"随机访问"。
     * 但有利就有弊，正因为这两个限制，让数组的很多操作也变得非常低效，比如想在数组中插入或删除一个元素，为了保证连续性，就需要做大量的搬移工作。
     */

    /***
     * 数组是如何根据下标访问元素的？
     * 我们拿一个长度为10的数组举例，int[] array = new int[10]
     * 计算机会给数据array分配一块连续的内存空间，1000~1039。
     * 因为是int值，所以数组中的每个元素有4个字节，所以每个元素的地址为1000~1003、1004~1007、1008~1011...1036~1039。
     * 内存块的首地址为1000，即base_address=1000，计算机通过地址来访问内存中的元素，当计算机需要访问某个元素时，它会根据下面的寻址公式来计算出该元素的地址
     * a[i]_address = base_address + i * data_type_size，其中data_type_size就是数据的字节大小，int为4个字节。
     */

    /***
     * 低效的"插入"和"删除"
     * 前面我们提到，数组为了保持内存连续性，会导致插入和删除这两个操作比较低效，这里我们就来详细看一下，为什么会这么低效？又有那些改进方法？
     *
     * 1.插入
     * 假设数组长度是n，现在我们要将一个元素插入到数组的第k个位置，为了把第k个位置给腾出来，我们需要将k~n这部分元素往后挪一位，我们来看看这个操作的复杂度。
     * 假如k在数组末尾，那么就不需要挪动，复杂度就是O(1)。
     * 假如k在数组首位，那么所以元素都得往后挪一位，因为有n个元素，那么代码的执行次数就是n次，复杂度就是O(n)
     * 因为我们插入每个位置的概率都是一样的，所以(1+2+3+...+n) * 1/n -> (n * (n+1))/2 * 1/n -> O(n)，所以平均复杂度就是O(n)
     *
     * 技巧
     * 如果数组中的数据是有序的，我们在某个位置插入一个元素时，就必须按照刚才的方法搬移k之后的数据。但是，如果数组中的数据没有任何规律，数组只是当做
     * 一个储存数据的集合。在这种情况下，如果要将元素插入到k位置，为了避免大规模的数据迁移，我们只需将k位置的元素搬到最后，把新的元素直接放到k即可。
     * 利用这种处理技巧，在特定场景下，在第k位置插入元素的复杂度就会降为O(1)，这种处理思想也在"快速排序"中用到，后面会在排序中详细讲解。
     */
    public void method1(){
        int[] array = new int[10];
        array[0] = 0;
        array[1] = 1;
        array[2] = 10;
        //将元素2放到数组第三个位置，原来的数据放到数组最后去
        array[array.length - 1] = array[2];
        array[2] = 2;
    }

    /***
     * 2.删除
     * 跟插入类似，如果我们要删除第k位置的元素，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。
     * 和插入类似，最好的情况复杂度是O(1)，最坏的情况复杂度是O(n)，平均复杂度是O(n)。
     *
     * 技巧
     * 在某些场景下，我们不一定非得追求数组中数据的连续性，如果我们将多次删除操作集中在一起执行，删除的效率会不会高很多呢？
     * 数组a[10]中储存了8个元素abcdefgh，现在我们要一次删除a、b、c三个元素。
     * 为了避免每次删除元素的时候d、e、f、g、h被搬移三次，我们可以先记录下已经删除的元素，每次的删除操作并不是真正的删除并搬移数据，
     * 而是记录一下需要删除的元素，当数组没有更多空间储存数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。
     * 这也是JVM标记清除垃圾回收算法的核心思想。
     */

    /***
     * 容器能否完全替代数组？
     * 针对数组类型，很多语言都提供了容器类，例如Java的ArrayList，如果你是Java工程师，几乎天天都在用ArrayList，那它与数组相比，到底有哪些优势呢？
     * ArrayList最大的优势就是可以将很多数据操作的细节封装起来，比如插入、删除。它还有一个优势，就是动态扩容。
     * 数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。如果数组大小不够用了，我们就需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。
     * 如果使用ArrayList，我们完全不需要关心扩容，ArrayList已经实现好了，每次自动扩容1.5倍。但如果事先知道数据大小，还是要指定ArrayList的大小为好。
     * 1.ArrayList无法存储基本类型，比如int、long，需要封装为Integer、Long，而AutoBoxing和UnBoxing有一定的性能消耗，所以特别关注性能或者希望使用基本类型，就可以选用数组。
     * 2.如果数据大小事先知道，并且对数据的操作非常简单，用不到ArrayList大部分方法，可以选用数组。
     * 3.当要表示多维数据时，数组往往更加直观。
     * 对于业务开发，直接使用容器就够了，省时省力。但如果你做一些非常底层的开发，性能的优化需要坐到极致，这个时候数组是首选。
     */
}
