package arithmetic.study.graph;

import org.junit.Test;

import java.util.HashMap;

/**
 * @author yangziyang
 * @since 2020-01-08
 * 图的表示
 */
public class day01 {

    /***
     * 邻接矩阵储存方法
     * 图最直观的一种储存方法就是邻接矩阵
     * 邻接矩阵底层依赖一个二维数组，对于无向图来说，如果顶点 i 与顶点 j 之间有边，我们就将 A[i][j] 和 A[j][i] 标记为 1。
     * 对于有向图来说，如果顶点 i 到顶点 j 之间，有一条箭头从顶点 i 指向顶点 j 的边，那我们就将 A[i][j] 标记为 1。同理，如果有一条箭头从顶点 j 指向顶点 i 的边，我们就将 A[j][i] 标记为 1。
     * 对于带权图，数组中就存储相应的权重。
     */

    /***
     * 无向图，模仿顶点1、5，顶点3、7添加好友的过程
     */
    @Test
    public void test(){
        MatrixArray array = new MatrixArray(10);
        array.add(1, 5);
        array.add(3, 7);
        array.print();
    }

    /***
     * 用邻接矩阵来表示一个图，虽然简单、直观，但是比较浪费存储空间。
     * 对于无向图来说，如果 A[i][j] 等于 1，那 A[j][i] 也肯定等于 1。实际上，我们只需要存储一个就可以了。
     * 也就是说，无向图的二维数组中，如果我们将其用对角线划分为上下两部分，那我们只需要利用上面或者下面这样一半的空间就足够了，另外一半白白浪费掉了。
     *
     * 但这也并不是说，邻接矩阵的存储方法就完全没有优点。首先，邻接矩阵的存储方式简单、直接，因为基于数组，所以在获取两个顶点的关系时，就非常高效。
     * 其次，用邻接矩阵存储图的另外一个好处是方便计算。这是因为，用邻接矩阵的方式存储图，可以将很多图的运算转换成矩阵之间的运算。
     */

    /***
     * 邻接表存储方法
     * 针对上面邻接矩阵比较浪费内存空间的问题，我们来看另外一种图的存储方法，邻接表。
     *
     */
}
